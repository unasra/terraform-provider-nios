/*
IbClient

OpenAPI 3.x.x specification for the IbClient API

API version: 3.0.0
Contact: jkhatri@infoblox.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/unasra/nios-go-client/internal"
)

type RecordaAPI interface {
	/*
		Get Method for Get

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RecordaAPIGetRequest
	*/
	Get(ctx context.Context) RecordaAPIGetRequest

	// GetExecute executes the request
	//  @return ListRecordAResponse
	GetExecute(r RecordaAPIGetRequest) (*ListRecordAResponse, *http.Response, error)
	/*
		Post Method for Post

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RecordaAPIPostRequest
	*/
	Post(ctx context.Context) RecordaAPIPostRequest

	// PostExecute executes the request
	//  @return CreateRecordAResponse
	PostExecute(r RecordaAPIPostRequest) (*CreateRecordAResponse, *http.Response, error)
	/*
		RecordaReferenceDelete Method for RecordaReferenceDelete

		Delete the record:a resource

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param recordaReference Enter the reference for record:a
		@return RecordaAPIRecordaReferenceDeleteRequest
	*/
	RecordaReferenceDelete(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceDeleteRequest

	// RecordaReferenceDeleteExecute executes the request
	RecordaReferenceDeleteExecute(r RecordaAPIRecordaReferenceDeleteRequest) (*http.Response, error)
	/*
		RecordaReferenceGet Method for RecordaReferenceGet

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param recordaReference Enter the reference for record:a
		@return RecordaAPIRecordaReferenceGetRequest
	*/
	RecordaReferenceGet(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceGetRequest

	// RecordaReferenceGetExecute executes the request
	//  @return GetRecordAResponse
	RecordaReferenceGetExecute(r RecordaAPIRecordaReferenceGetRequest) (*GetRecordAResponse, *http.Response, error)
	/*
		RecordaReferencePut Method for RecordaReferencePut

		Update the record:a resource

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param recordaReference Enter the reference for record:a
		@return RecordaAPIRecordaReferencePutRequest
	*/
	RecordaReferencePut(ctx context.Context, recordaReference string) RecordaAPIRecordaReferencePutRequest

	// RecordaReferencePutExecute executes the request
	//  @return UpdateRecordAResponse
	RecordaReferencePutExecute(r RecordaAPIRecordaReferencePutRequest) (*UpdateRecordAResponse, *http.Response, error)
}

// RecordaAPIService RecordaAPI service
type RecordaAPIService internal.Service

type RecordaAPIGetRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	returnFields     *string
	returnFields2    *string
	maxResults       *int32
	returnAsObject   *int32
	paging           *int32
	pageId           *string
	proxySearch      *string
	schema           *string
	schemaVersion    *int32
	getDoc           *int32
	schemaSearchable *int32
	inheritance      *bool
	body             *map[string]interface{}
}

// Enter the field names followed by comma
func (r RecordaAPIGetRequest) ReturnFields(returnFields string) RecordaAPIGetRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIGetRequest) ReturnFields2(returnFields2 string) RecordaAPIGetRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Enter the number of results to be fetched
func (r RecordaAPIGetRequest) MaxResults(maxResults int32) RecordaAPIGetRequest {
	r.maxResults = &maxResults
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIGetRequest) ReturnAsObject(returnAsObject int32) RecordaAPIGetRequest {
	r.returnAsObject = &returnAsObject
	return r
}

// Select 1 if paging is required. If SET, _max_results and _return_as_object must be entered.
func (r RecordaAPIGetRequest) Paging(paging int32) RecordaAPIGetRequest {
	r.paging = &paging
	return r
}

// Enter the page ID for fetching the next page
func (r RecordaAPIGetRequest) PageId(pageId string) RecordaAPIGetRequest {
	r.pageId = &pageId
	return r
}

// If set to GM, the request is redirected to Grid master for processing. If set to LOCAL, the request is processed locally. This option is applicable only on vConnector grid members. The default is LOCAL.
func (r RecordaAPIGetRequest) ProxySearch(proxySearch string) RecordaAPIGetRequest {
	r.proxySearch = &proxySearch
	return r
}

// If this option is specified, a WAPI schema will be returned
func (r RecordaAPIGetRequest) Schema(schema string) RecordaAPIGetRequest {
	r.schema = &schema
	return r
}

// If this option is specified, a WAPI schema of particular version will be returned. If options is omitted, schema version is assumed to be 1
func (r RecordaAPIGetRequest) SchemaVersion(schemaVersion int32) RecordaAPIGetRequest {
	r.schemaVersion = &schemaVersion
	return r
}

// When set to 1, it returns the documentation of the object.Applicable only when _schema_version is 2
func (r RecordaAPIGetRequest) GetDoc(getDoc int32) RecordaAPIGetRequest {
	r.getDoc = &getDoc
	return r
}

// If this option is specified, search only fields will also be returned. Applicable only when _schema_version is 2
func (r RecordaAPIGetRequest) SchemaSearchable(schemaSearchable int32) RecordaAPIGetRequest {
	r.schemaSearchable = &schemaSearchable
	return r
}

// If this option is set to True, fields which support inheritance, will display data properly.
func (r RecordaAPIGetRequest) Inheritance(inheritance bool) RecordaAPIGetRequest {
	r.inheritance = &inheritance
	return r
}

// Enter the GET request body here
func (r RecordaAPIGetRequest) Body(body map[string]interface{}) RecordaAPIGetRequest {
	r.body = &body
	return r
}

func (r RecordaAPIGetRequest) Execute() (*ListRecordAResponse, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Method for Get

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RecordaAPIGetRequest
*/
func (a *RecordaAPIService) Get(ctx context.Context) RecordaAPIGetRequest {
	return RecordaAPIGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListRecordAResponse
func (a *RecordaAPIService) GetExecute(r RecordaAPIGetRequest) (*ListRecordAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ListRecordAResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.Get")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.maxResults != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_max_results", r.maxResults, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	if r.paging != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_paging", r.paging, "")
	} else {
		var defaultValue int32 = 0
		r.paging = &defaultValue
	}
	if r.pageId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_id", r.pageId, "")
	}
	if r.proxySearch != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_proxy_search", r.proxySearch, "")
	}
	if r.schema != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_schema", r.schema, "")
	}
	if r.schemaVersion != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_schema_version", r.schemaVersion, "")
	}
	if r.getDoc != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_get_doc", r.getDoc, "")
	}
	if r.schemaSearchable != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_schema_searchable", r.schemaSearchable, "")
	}
	if r.inheritance != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_inheritance", r.inheritance, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIPostRequest struct {
	ctx            context.Context
	ApiService     RecordaAPI
	recordA        *RecordA
	returnFields   *string
	returnFields2  *string
	returnAsObject *int32
}

// Enter the request body here
func (r RecordaAPIPostRequest) RecordA(recordA RecordA) RecordaAPIPostRequest {
	r.recordA = &recordA
	return r
}

// Enter the field names followed by comma
func (r RecordaAPIPostRequest) ReturnFields(returnFields string) RecordaAPIPostRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIPostRequest) ReturnFields2(returnFields2 string) RecordaAPIPostRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIPostRequest) ReturnAsObject(returnAsObject int32) RecordaAPIPostRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r RecordaAPIPostRequest) Execute() (*CreateRecordAResponse, *http.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post Method for Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RecordaAPIPostRequest
*/
func (a *RecordaAPIService) Post(ctx context.Context) RecordaAPIPostRequest {
	return RecordaAPIPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateRecordAResponse
func (a *RecordaAPIService) PostExecute(r RecordaAPIPostRequest) (*CreateRecordAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateRecordAResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.Post")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recordA == nil {
		return localVarReturnValue, nil, internal.ReportError("recordA is required and must be specified")
	}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recordA
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIRecordaReferenceDeleteRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	recordaReference string
	returnFields     *string
	returnFields2    *string
	returnAsObject   *int32
}

// Enter the field names followed by comma
func (r RecordaAPIRecordaReferenceDeleteRequest) ReturnFields(returnFields string) RecordaAPIRecordaReferenceDeleteRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIRecordaReferenceDeleteRequest) ReturnFields2(returnFields2 string) RecordaAPIRecordaReferenceDeleteRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIRecordaReferenceDeleteRequest) ReturnAsObject(returnAsObject int32) RecordaAPIRecordaReferenceDeleteRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r RecordaAPIRecordaReferenceDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecordaReferenceDeleteExecute(r)
}

/*
RecordaReferenceDelete Method for RecordaReferenceDelete

Delete the record:a resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordaReference Enter the reference for record:a
	@return RecordaAPIRecordaReferenceDeleteRequest
*/
func (a *RecordaAPIService) RecordaReferenceDelete(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceDeleteRequest {
	return RecordaAPIRecordaReferenceDeleteRequest{
		ApiService:       a,
		ctx:              ctx,
		recordaReference: recordaReference,
	}
}

// Execute executes the request
func (a *RecordaAPIService) RecordaReferenceDeleteExecute(r RecordaAPIRecordaReferenceDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.RecordaReferenceDelete")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a/{record:a_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"record:a_reference"+"}", url.PathEscape(internal.ParameterValueToString(r.recordaReference, "recordaReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RecordaAPIRecordaReferenceGetRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	recordaReference string
	returnFields     *string
	returnFields2    *string
	returnAsObject   *int32
}

// Enter the field names followed by comma
func (r RecordaAPIRecordaReferenceGetRequest) ReturnFields(returnFields string) RecordaAPIRecordaReferenceGetRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIRecordaReferenceGetRequest) ReturnFields2(returnFields2 string) RecordaAPIRecordaReferenceGetRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIRecordaReferenceGetRequest) ReturnAsObject(returnAsObject int32) RecordaAPIRecordaReferenceGetRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r RecordaAPIRecordaReferenceGetRequest) Execute() (*GetRecordAResponse, *http.Response, error) {
	return r.ApiService.RecordaReferenceGetExecute(r)
}

/*
RecordaReferenceGet Method for RecordaReferenceGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordaReference Enter the reference for record:a
	@return RecordaAPIRecordaReferenceGetRequest
*/
func (a *RecordaAPIService) RecordaReferenceGet(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceGetRequest {
	return RecordaAPIRecordaReferenceGetRequest{
		ApiService:       a,
		ctx:              ctx,
		recordaReference: recordaReference,
	}
}

// Execute executes the request
//
//	@return GetRecordAResponse
func (a *RecordaAPIService) RecordaReferenceGetExecute(r RecordaAPIRecordaReferenceGetRequest) (*GetRecordAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *GetRecordAResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.RecordaReferenceGet")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a/{record:a_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"record:a_reference"+"}", url.PathEscape(internal.ParameterValueToString(r.recordaReference, "recordaReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIRecordaReferencePutRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	recordaReference string
	recordA          *RecordA
	returnFields     *string
	returnFields2    *string
	returnAsObject   *int32
}

// Enter the request body here
func (r RecordaAPIRecordaReferencePutRequest) RecordA(recordA RecordA) RecordaAPIRecordaReferencePutRequest {
	r.recordA = &recordA
	return r
}

// Enter the field names followed by comma
func (r RecordaAPIRecordaReferencePutRequest) ReturnFields(returnFields string) RecordaAPIRecordaReferencePutRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIRecordaReferencePutRequest) ReturnFields2(returnFields2 string) RecordaAPIRecordaReferencePutRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIRecordaReferencePutRequest) ReturnAsObject(returnAsObject int32) RecordaAPIRecordaReferencePutRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r RecordaAPIRecordaReferencePutRequest) Execute() (*UpdateRecordAResponse, *http.Response, error) {
	return r.ApiService.RecordaReferencePutExecute(r)
}

/*
RecordaReferencePut Method for RecordaReferencePut

Update the record:a resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordaReference Enter the reference for record:a
	@return RecordaAPIRecordaReferencePutRequest
*/
func (a *RecordaAPIService) RecordaReferencePut(ctx context.Context, recordaReference string) RecordaAPIRecordaReferencePutRequest {
	return RecordaAPIRecordaReferencePutRequest{
		ApiService:       a,
		ctx:              ctx,
		recordaReference: recordaReference,
	}
}

// Execute executes the request
//
//	@return UpdateRecordAResponse
func (a *RecordaAPIService) RecordaReferencePutExecute(r RecordaAPIRecordaReferencePutRequest) (*UpdateRecordAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *UpdateRecordAResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.RecordaReferencePut")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a/{record:a_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"record:a_reference"+"}", url.PathEscape(internal.ParameterValueToString(r.recordaReference, "recordaReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recordA == nil {
		return localVarReturnValue, nil, internal.ReportError("recordA is required and must be specified")
	}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recordA
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
